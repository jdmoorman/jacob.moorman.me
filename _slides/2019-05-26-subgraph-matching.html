---
layout: presentation
title: Subgraph Matching (Advancement to Candidacy)
order: 9
---

## Subgraph Matching

**Jacob Moorman**

&nbsp;

In collaboration with

*Thomas Tu, Qinyi Chen, Xie He, and Andrea Bertozzi*

of UCLA Department of Mathematics




-vertical-

Work funded by DARPA

under the Modeling Adversarial Activity (MAA) program




-vertical-

Jacob was funded by NSF grant DGE-1829071




-horizontal-

## Subgraph Matching Problem

Find all copies of a **template** graph in a **world** graph

<img class="plain" src="definitions-example.png" width="50%">

An instance of the *template* in the *world* is called a **signal**





-vertical-

## Main Algorithm: Tree Search

  1. Find all signals where \\(\mathbf{A} = \mathbf{1}\\)
    1. Find all signals where \\(\mathbf{A} = \mathbf{1}\\) and \\(\mathbf{C} = \mathbf{6}\\)
      1. ...
  2. Find all signals where \\(\mathbf{A} = \mathbf{4}\\)
  3. ...

<img class="plain" src="definitions-example.png" width="50%">




-vertical-

## Tree Search Considerations

* **Search Order:** In what order should we match the template nodes?
* **Pruning Rules:** To which world nodes should we try matching them?

<img class="plain" src="definitions-example.png" width="50%">




-horizontal-

## Search Order

> *In what order should we match the template nodes?*

Use a heuristic to precompute a fixed order on the template nodes.




-vertical-

## Search Order Heuristics

* Fewest candidates first
* Highest degree first
* Most neighbors first
* ...

<img class="plain" src="definitions-example.png" width="50%">




-vertical-

## Search Order Objective

The objective in choosing a search order is to minimize the computational cost of traversing the search tree.




-horizontal-

## Pruning Rules

> To which world nodes should we try matching the template nodes?

Try matching each template node to world nodes which satisfy some set of constraints. Refer to these world nodes as **candidates**.




-vertical-

## Pruning Rules:
#### Node-level Statistics

A candidate should have as many incoming/outgoing edges as its corresponding template nodes

<img class="plain" src="cheap-filters-example.png" width="50%">

[insert table here]




-horizontal-

## Our Work

* Stats filter
* Topology filter
* Neighborhood filter
* Permutation filter
* Public GitHub code

<img class="plain" src="neighborhood-example.png" width="50%">




-horizontal-

## Future Work




-horizontal-

## References

* Fewest candidates first search order heuristic
  * [He2008] H. He and A. K. Singh. Graphs-at-a-time: query language and access methods for graph databases. In SIGMOD, 2008.




-horizontal-

# Junk Slides





-vertical-

## Three main approaches

* Tree Search
* Constraint Propagation
* Graph Indexing
